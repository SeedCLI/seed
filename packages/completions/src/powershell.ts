import type { CompletionCommand, CompletionInfo } from "./types.js";
import { sanitizeShellToken } from "./types.js";

const MAX_COMPLETION_DEPTH = 20;

/**
 * Escape a string for safe use in PowerShell single-quoted strings.
 * In PowerShell, single-quoted strings only need '' to represent a literal '.
 * Also remove backticks and $ to prevent expression injection.
 */
function escapePowerShellString(value: string): string {
	return value.replace(/'/g, "''").replace(/[`$]/g, "");
}

function generateCommandCompletions(cmd: CompletionCommand, indent: string): string[] {
	const lines: string[] = [];

	// Add subcommands
	if (cmd.subcommands) {
		for (const sub of cmd.subcommands) {
			const safeName = sanitizeShellToken(sub.name);
			const desc = sub.description ? escapePowerShellString(sub.description) : safeName;
			lines.push(
				`${indent}[CompletionResult]::new('${safeName}', '${desc}', [CompletionResultType]::ParameterValue, '${desc}')`,
			);
		}
	}

	// Add flags
	if (cmd.flags) {
		for (const f of cmd.flags) {
			const safeFlagName = sanitizeShellToken(f.name);
			const desc = f.description ? escapePowerShellString(f.description) : `--${safeFlagName}`;
			lines.push(
				`${indent}[CompletionResult]::new('--${safeFlagName}', '${desc}', [CompletionResultType]::ParameterName, '${desc}')`,
			);
			if (f.alias) {
				const safeAlias = sanitizeShellToken(f.alias);
				lines.push(
					`${indent}[CompletionResult]::new('-${safeAlias}', '${desc}', [CompletionResultType]::ParameterName, '${desc}')`,
				);
			}
		}
	}

	return lines;
}

/**
 * Recursively generate switch cases for a command and all its subcommands.
 * Uses an underscore-joined key path (e.g., "db_migrate") to match the
 * compound key built from non-flag tokens at runtime.
 */
function generateCommandCases(cmd: CompletionCommand, path: string, depth = 0): string[] {
	if (depth > MAX_COMPLETION_DEPTH) return [];

	const cases: string[] = [];
	const safeName = sanitizeShellToken(cmd.name);
	const key = path ? `${path}_${safeName}` : safeName;
	const indent = "                ";

	const completions = generateCommandCompletions(cmd, indent);
	if (completions.length > 0) {
		cases.push(`            '${key}' {
${completions.join("\n")}
            }`);
	}

	// Recurse for subcommands
	if (cmd.subcommands) {
		for (const sub of cmd.subcommands) {
			cases.push(...generateCommandCases(sub, key, depth + 1));
		}
	}

	return cases;
}

/**
 * Generate a PowerShell `Register-ArgumentCompleter` script.
 *
 * Uses a compound key built from all non-flag tokens (joined with underscores)
 * so that nested subcommand completions are reachable. For example,
 * `mycli db migrate <TAB>` builds the key "db_migrate" which matches the
 * switch case generated by generateCommandCases.
 */
export function powershell(info: CompletionInfo): string {
	const { brand, commands } = info;
	const safeBrand = sanitizeShellToken(brand);

	const commandCases: string[] = [];
	for (const cmd of commands) {
		commandCases.push(...generateCommandCases(cmd, ""));
	}

	const topLevelCompletions = commands
		.map((c) => {
			const safeName = sanitizeShellToken(c.name);
			const desc = c.description ? escapePowerShellString(c.description) : safeName;
			return `            [CompletionResult]::new('${safeName}', '${desc}', [CompletionResultType]::ParameterValue, '${desc}')`;
		})
		.join("\n");

	return `# PowerShell completions for ${safeBrand}
# Generated by @seedcli/completions

Register-ArgumentCompleter -CommandName '${safeBrand}' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $tokens = $commandAst.ToString().Split(' ', [StringSplitOptions]::RemoveEmptyEntries)

    if ($tokens.Length -le 1) {
${topLevelCompletions}
        return
    }

    # Build a compound key from all non-flag tokens after the command name.
    # e.g. "mycli db migrate <TAB>" -> key = "db_migrate"
    $key = ''
    for ($i = 1; $i -lt $tokens.Length; $i++) {
        if ($tokens[$i] -like '-*') { continue }
        if ($key -ne '') { $key += '_' }
        $key += $tokens[$i]
    }

    switch ($key) {
${commandCases.join("\n")}
    }
} | Where-Object { $_.CompletionText -like "$wordToComplete*" }
`;
}
