function generateCommandCase(brand, cmd, path) {
    const lines = [];
    const casePattern = path ? `${path}_${cmd.name}` : cmd.name;
    // Gather completions for this command
    const words = [];
    // Add subcommands
    if (cmd.subcommands) {
        for (const sub of cmd.subcommands) {
            words.push(sub.name);
        }
    }
    // Add flags
    if (cmd.flags) {
        for (const f of cmd.flags) {
            words.push(`--${f.name}`);
            if (f.alias)
                words.push(`-${f.alias}`);
        }
    }
    if (words.length > 0) {
        lines.push(`        ${casePattern})`);
        lines.push(`            COMPREPLY=( $(compgen -W "${words.join(" ")}" -- "\${cur}") )`);
        lines.push("            return 0");
        lines.push("            ;;");
    }
    // Recurse for subcommands
    if (cmd.subcommands) {
        for (const sub of cmd.subcommands) {
            lines.push(generateCommandCase(brand, sub, casePattern));
        }
    }
    return lines.join("\n");
}
/**
 * Generate a bash completion script.
 */
export function bash(info) {
    const { brand, commands } = info;
    const topLevelWords = commands.flatMap((c) => [c.name, ...(c.aliases ?? [])]).join(" ");
    const caseClauses = [];
    for (const cmd of commands) {
        caseClauses.push(generateCommandCase(brand, cmd, ""));
    }
    return `# Bash completions for ${brand}
# Generated by @seedcli/completions

_${brand}_completions() {
    local cur prev words cword
    _init_completion || return

    if [[ \${cword} -eq 1 ]]; then
        COMPREPLY=( $(compgen -W "${topLevelWords}" -- "\${cur}") )
        return 0
    fi

    local command="\${words[1]}"

    case "\${command}" in
${caseClauses.join("\n")}
        *)
            ;;
    esac
}

complete -F _${brand}_completions ${brand}
`;
}
//# sourceMappingURL=bash.js.map