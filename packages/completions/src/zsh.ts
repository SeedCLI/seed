import type { CompletionCommand, CompletionInfo } from "./types.js";
import { escapeShellDescription, sanitizeShellToken } from "./types.js";

const MAX_COMPLETION_DEPTH = 20;

function generateSubcommandFunction(
	brand: string,
	cmd: CompletionCommand,
	prefix: string,
	depth = 0,
): string[] {
	if (depth > MAX_COMPLETION_DEPTH) return [];

	const blocks: string[] = [];
	const safeName = sanitizeShellToken(cmd.name);
	const fnName = prefix ? `_${brand}_${prefix}_${safeName}` : `_${brand}_${safeName}`;

	const args: string[] = [];

	// Add subcommand descriptions
	if (cmd.subcommands && cmd.subcommands.length > 0) {
		const subcmdDescs = cmd.subcommands
			.map((s) => `'${sanitizeShellToken(s.name)}:${escapeShellDescription(s.description ?? "")}'`)
			.join(" ");
		args.push(`'1:command:(${cmd.subcommands.map((s) => sanitizeShellToken(s.name)).join(" ")})'`);
		blocks.push(`# Subcommands: ${subcmdDescs}`);
	}

	// Add flags
	if (cmd.flags) {
		for (const f of cmd.flags) {
			const safeFlagName = sanitizeShellToken(f.name);
			const desc = escapeShellDescription(f.description ?? "")
				.replace(/\[/g, "\\[")
				.replace(/\]/g, "\\]");
			if (f.choices && f.choices.length > 0) {
				const safeChoices = f.choices.map(sanitizeShellToken).join(" ");
				args.push(`'--${safeFlagName}[${desc}]:value:(${safeChoices})'`);
			} else {
				args.push(`'--${safeFlagName}[${desc}]'`);
			}
			if (f.alias) {
				args.push(`'-${sanitizeShellToken(f.alias)}[${desc}]'`);
			}
		}
	}

	blocks.push(`${fnName}() {`);
	blocks.push("    _arguments \\");
	for (let i = 0; i < args.length; i++) {
		blocks.push(`        ${args[i]}${i < args.length - 1 ? " \\" : ""}`);
	}
	blocks.push("}");

	// Recurse for subcommands
	if (cmd.subcommands) {
		for (const sub of cmd.subcommands) {
			const nextPrefix = prefix ? `${prefix}_${safeName}` : safeName;
			blocks.push(...generateSubcommandFunction(brand, sub, nextPrefix, depth + 1));
		}
	}

	return blocks;
}

/**
 * Generate a zsh completion script using `#compdef`.
 */
export function zsh(info: CompletionInfo): string {
	const { brand, commands } = info;
	const safeBrand = sanitizeShellToken(brand);

	const functionBlocks: string[] = [];
	for (const cmd of commands) {
		functionBlocks.push(...generateSubcommandFunction(safeBrand, cmd, ""));
	}

	return `#compdef ${safeBrand}
# Zsh completions for ${safeBrand}
# Generated by @seedcli/completions

_${safeBrand}() {
    local -a commands
    commands=(
        ${commands.map((c) => `'${sanitizeShellToken(c.name)}:${escapeShellDescription(c.description ?? "")}'`).join("\n        ")}
    )

    _arguments \\
        '1:command:->command' \\
        '*::arg:->args'

    case "$state" in
        command)
            _describe -t commands 'commands' commands
            ;;
        args)
            case "\${words[1]}" in
                ${commands.map((c) => `${sanitizeShellToken(c.name)}) _${safeBrand}_${sanitizeShellToken(c.name)} ;;`).join("\n                ")}
            esac
            ;;
    esac
}

${functionBlocks.join("\n\n")}

_${safeBrand} "$@"
`;
}
