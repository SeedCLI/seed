import type { CompletionCommand, CompletionInfo } from "./types.js";

function generateSubcommandFunction(
	brand: string,
	cmd: CompletionCommand,
	prefix: string,
): string[] {
	const blocks: string[] = [];
	const fnName = prefix ? `_${brand}_${prefix}_${cmd.name}` : `_${brand}_${cmd.name}`;

	const args: string[] = [];

	// Add subcommand descriptions
	if (cmd.subcommands && cmd.subcommands.length > 0) {
		const subcmdDescs = cmd.subcommands
			.map((s) => `'${s.name}:${(s.description ?? "").replace(/'/g, "'\\''")}'`)
			.join(" ");
		args.push(`'1:command:(${cmd.subcommands.map((s) => s.name).join(" ")})'`);
		blocks.push(`# Subcommands: ${subcmdDescs}`);
	}

	// Add flags
	if (cmd.flags) {
		for (const f of cmd.flags) {
			const desc = (f.description ?? "")
				.replace(/'/g, "'\\''")
				.replace(/\[/g, "\\[")
				.replace(/\]/g, "\\]");
			if (f.choices && f.choices.length > 0) {
				args.push(`'--${f.name}[${desc}]:value:(${f.choices.join(" ")})'`);
			} else {
				args.push(`'--${f.name}[${desc}]'`);
			}
			if (f.alias) {
				args.push(`'-${f.alias}[${desc}]'`);
			}
		}
	}

	blocks.push(`${fnName}() {`);
	blocks.push("    _arguments \\");
	for (let i = 0; i < args.length; i++) {
		blocks.push(`        ${args[i]}${i < args.length - 1 ? " \\" : ""}`);
	}
	blocks.push("}");

	// Recurse for subcommands
	if (cmd.subcommands) {
		for (const sub of cmd.subcommands) {
			const nextPrefix = prefix ? `${prefix}_${cmd.name}` : cmd.name;
			blocks.push(...generateSubcommandFunction(brand, sub, nextPrefix));
		}
	}

	return blocks;
}

/**
 * Generate a zsh completion script using `#compdef`.
 */
export function zsh(info: CompletionInfo): string {
	const { brand, commands } = info;

	const functionBlocks: string[] = [];
	for (const cmd of commands) {
		functionBlocks.push(...generateSubcommandFunction(brand, cmd, ""));
	}

	return `#compdef ${brand}
# Zsh completions for ${brand}
# Generated by @seedcli/completions

_${brand}() {
    local -a commands
    commands=(
        ${commands.map((c) => `'${c.name}:${(c.description ?? "").replace(/'/g, "'\\''")}'`).join("\n        ")}
    )

    _arguments \\
        '1:command:->command' \\
        '*::arg:->args'

    case "$state" in
        command)
            _describe -t commands 'commands' commands
            ;;
        args)
            case "\${words[1]}" in
                ${commands.map((c) => `${c.name}) _${brand}_${c.name} ;;`).join("\n                ")}
            esac
            ;;
    esac
}

${functionBlocks.join("\n\n")}

_${brand} "$@"
`;
}
